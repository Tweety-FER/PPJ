import java.io.IOException;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

public class SemantickiAnalizator {

	private static SyntacticTreeNode root;
	private static Type functionReturnType;
	private static int loopCounter;
	private static SymbolTable table;
	private static FRISCCommandBuilder builder;

	public static void main(String[] args) {
		try {
			builder = new FRISCCommandBuilder();
			table = GlobalSymbolTableProvider.instance();
			root = TreeParser.read(System.in);
			loopCounter = 0;
			functionReturnType = Type.None;
			builder.init();
			prijevodna_jedinica(root);
			
			Symbol main = table.getRoot().getSymbol("main");
			if (main == null
					|| !main.isFunction()
					|| !main.signature.equals(new Pair<Type, List<Type>>(
							Type.Int, new ArrayList<Type>()))) {
				System.out.println("main");
				System.exit(101);
			}

			if (!table.allFunctionsDefined()) {
				System.out.println("funkcija");
				System.exit(102);
			}
			
			builder.finalize();

		} catch (IOException e) {
			System.err.println("Cannot read System.in. Much confuse.");
			System.exit(20);
		}

	}

	private static void primarni_izraz(SyntacticTreeNode node) {
		SyntacticTreeNode child0 = node.getChildren().get(0);
		SyntaxInformationPacket data = child0.getInfoPacket();

		if (data.type.equals("IDN")) {
			Symbol idn = table.getSymbol(data.contents);
			if (idn == null) {
				perror(node);
			}
			if (idn.isFunction()) {
				node.setFunctionSignature(idn.signature.x, idn.signature.y);
				//TODO I honestly have no idea. I think it should just store the function name
				//Somewhere internally for when it is needed later. Experiment
				//STILL haven't implemented that one, I am not sure what we ought to do here.
			} else {
				node.setType(idn.type);
				node.setLExpression(true);
				//Telling it that it should have a variable somewhere and that its contents should be
				//Put on stack.
				builder.putVariable(idn.name);
			}
		} else if (data.type.equals("BROJ")) {
			if (!isInt(data.contents)) {
				perror(node);
			}
			node.setType(Type.Int);
			node.setLExpression(false);
			//Getting contents string repr of number and then extracting value
			builder.putConstant(Integer.valueOf(data.contents));

		} else if (data.type.equals("ZNAK")) {
			if (!isChar(data.contents)) {
				perror(node);
			}

			node.setType(Type.Char);
			node.setLExpression(false);
			//Get integer value of contents of character
			builder.putConstant(extractCharacterValue(data.contents));
			
		} else if (data.type.equals("NIZ_ZNAKOVA")) {
			if (!isString(data.contents)) {
				perror(node);
			}

			node.setType(Type.ConstArrayChar);
			node.setLExpression(false);
			//NOT sure if this will actuall work, maybe it needs to be reversed? (Stack instead of List)
			List<Integer> strVals = extractStringValue(data.contents);
			for(Integer val : strVals) {
				builder.putConstant(val);
			}
			builder.putConstant(0); //Terminating \0
			
		} else if (data.type.equals("L_ZAGRADA")) {
			SyntacticTreeNode child1 = node.getChild(1);
			izraz(child1);
			node.inheritType(child1);
			node.setLExpression(child1.isLExpression());
		}

	}

	private static void postfiks_izraz(SyntacticTreeNode node) {
		SyntacticTreeNode child0 = node.getChild(0);
		SyntaxInformationPacket data = child0.getInfoPacket();
		if (data.type.equals("<primarni_izraz>")) {
			primarni_izraz(child0);
			node.inheritType(child0);
			node.setLExpression(child0.isLExpression());

		} else if (data.type.equals("<postfiks_izraz>")) {
			postfiks_izraz(child0);

			SyntaxInformationPacket lBracket = node.getChild(1).getInfoPacket();

			if (lBracket.type.equals("L_UGL_ZAGRADA")) {
				if (!TypeCast.isArray(child0.getType(), true)) {
					perror(node);
				}

				izraz(node.getChild(2));
				if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int,
						false)) {
					perror(node);
				}

				Type X = TypeCast.fromArray(child0.getType());
				node.setType(X);
				node.setLExpression(!TypeCast.isConst(X, false));
				//TODO Get value generated by izraz, as an integer value, find the address of array
				// and shift it by the calculated offset (could be tricky, as - for stack, + for global,
				//maybe implement a function in the builder) and push it to stack
			} else if (lBracket.type.equals("L_ZAGRADA")
					&& node.getChildren().size() == 3) {
				if (!(child0.isFunction() && child0.getArgumentTypes()
						.isEmpty())) {
					perror(node);
				}
				node.setType(child0.getReturnType());
				
				//TODO
				//Descend through the nodes to get the function name or maybe it is already stored somewhere?
				// (See primarni_izraz todo for possible handling of functions)
				//Find function tag for given name
				//Call the function with Enter Function function in builder
			} else if (lBracket.type.equals("L_ZAGRADA")
					&& node.getChildren().size() == 4) {
				lista_argumenata(node.getChild(2));
				List<Type> arguments = node.getChild(2).getTypes();

				if (!(child0.isFunction() && arguments.size() == child0
						.getArgumentTypes().size())) {
					perror(node);
				}

				boolean argumentsMatch = true;
				for (int i = 0; i < arguments.size(); i++) {
					argumentsMatch = argumentsMatch
							&& TypeCast.canCastFromTo(arguments.get(i), child0
									.getArgumentTypes().get(i), false);
				}

				if (!argumentsMatch) {
					perror(node);
				}

				node.setType(child0.getReturnType());
				//TODO
				//Descend through the nodes to get the function name
				//Find function tag for given name
				//Get all the variables
				//Call the function with Enter Function function in builder

			} else if (lBracket.type.equals("OP_INC")
					|| lBracket.type.equals("OP_DEC")) {
				if (!(child0.isLExpression() && TypeCast.canCastNodeFromTo(
						child0, Type.Int, false))) {
					perror(node);
				}
				
				//TODO
				//Get value
				//Push it
				//Increase by one
				//Store it back, either to stack or global (can be abstracted, probably)
			}
		}
	}

	private static void izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			izraz_pridruzivanja(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			izraz(node.getChild(0));
			izraz_pridruzivanja(node.getChild(2));
			node.inheritType(node.getChild(2));
		}
	}

	private static void izraz_pridruzivanja(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			log_ili_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			postfiks_izraz(node.getChild(0));
			if (!(node.getChild(0).isLExpression())) {
				perror(node);
			}

			izraz_pridruzivanja(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), node.getChild(0)
					.getType(), false)) {
				perror(node);
			}

			node.inheritType(node.getChild(2));
			//TODO Get left operand address (tag or offset)
			//Get value of right operand (should have been pushed to stack)
			//Pop it into the left operand
			//Could get messy for arrays
		}
	}

	private static void lista_argumenata(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			izraz_pridruzivanja(node.getChild(0));
			node.addType(node.getChild(0).getType());
		} else {
			lista_argumenata(node.getChild(0));
			izraz_pridruzivanja(node.getChild(2));
			node.setTypes(node.getChild(0).getTypes());
			node.addType(node.getChild(2).getType());
		}
	}

	private static void unarni_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			postfiks_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			if (node.getChild(0).getInfoPacket().type
					.equals("<unarni_operator>")) {
				cast_izraz(node.getChild(1));
				if (!(TypeCast.canCastNodeFromTo(node.getChild(1), Type.Int,
						false))) {
					perror(node);
				}
				//TODO Depending what the unary operator is, apply it to the operand
				//Probably just descend down the <unarni_operator> node to get the contents
				//and switch case. Unary operator can be +, -, ~ (negate bits) and !
				//PERFORM ON VALUE, NOT VARIABLE!
			} else {
				unarni_izraz(node.getChild(1));
				if (!(node.getChild(1).isLExpression() && TypeCast
						.canCastNodeFromTo(node.getChild(1), Type.Int, false))) {
					perror(node);
				}
				//TODO ++a or --a.
				//Read value (either as offset or global tag), increment or decrement, store and then push
			}
			node.setType(Type.Int);
		}
	}

	private static void cast_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			unarni_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			ime_tipa(node.getChild(1));
			cast_izraz(node.getChild(3));

			if (!(TypeCast.canCastNodeFromTo(node.getChild(3), node.getChild(1)
					.getType(), true))) {
				perror(node);
			}

			node.inheritType(node.getChild(1));
			//TODO Possibly switching from integer to character and back.
			//Proper functions SHOULD be provided in the builder.
			//Not sure if actually needs implementing
		}
	}

	private static void ime_tipa(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			specifikator_tipa(node.getChild(0));
			node.inheritType(node.getChild(0));
			
			//TODO Reads type name or void. Possibly some casting, probably nothing.
		} else {
			specifikator_tipa(node.getChild(1));
			if (node.getChild(1).getType().equals(Type.Void)) {
				perror(node);
			}

			node.setType(TypeCast.toConst(node.getChild(1).getType()));
			//TODO As above, probably nothing.
		}
	}

	private static void specifikator_tipa(SyntacticTreeNode node) {
		SyntaxInformationPacket info = node.getChild(0).getInfoPacket();

		if (info.type.equals("KR_VOID")) {
			node.setType(Type.Void);
		} else if (info.type.equals("KR_CHAR")) {
			node.setType(Type.Char);
		} else {
			node.setType(Type.Int);
		}
	}

	private static void multiplikativni_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			cast_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			multiplikativni_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}

			cast_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			
			char operationRepr = node.getChild(1).getInfoPacket().contents.charAt(0); //Read operator *, / or %
			//Both operands should be on stack, y above x, so no popping here
			switch(operationRepr) {
				case '*': builder.freeStyle("\tCALL MULT_BUILTIN"); break;
				case '/': builder.freeStyle("\tCALL DIV_BUILTIN"); break;
				case '%': builder.freeStyle("\tCALL MOD_BUILTIN"); break;
				default: break;
			}
		}
	}

	private static void aditivni_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			multiplikativni_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			aditivni_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}
			multiplikativni_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			String op = node.getChild(1).getInfoPacket().type;
			//The other way to differentiate between types, using lexical units instead of contents
			//See above for first
			if(op.equals("PLUS")) {
				builder.doBinaryOp("ADD", null);
			} else {
				builder.doBinaryOp("SUB", null);
			}
		}
	}

	private static void odnosni_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			aditivni_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			odnosni_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}

			aditivni_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			//TODO Podsjetite me da vas zadavim. Pa kako ovo ne mozete implementirati?!
			//Doslovno sam vam tu napisao kaj treba za >=, samo treba apstrahirati tako da
			//se DOSLOVNO promjeni JP_x u neki x ovisno o tipu usporedbe
			//Predlazem u builderu da se napravi slicna funkcija kao doBinaryOp samo doComparisonOp
			
			//TODO Get left and right values (should be on stack, in right order) and
			//depending on the operation (child 1) call CMP followed by checked whether
			//the the condition (e.g. LTE, GT, ...) is true. If true, add a part where it
			//just to pushing a value 1 to stack, if false jump to part pushing a value 0
			//on stack.
			//e.g. GTE
			//	POP R1 // y
			//	POP R0 //x
			//	CMP R0 R1
			//	JP_SGE TRUE_1 //Signed >=, implement some sort of a counter for this, so it's TRUE_[unique num]
			//	// Always signed, we do not have an unsigned type
			// 	MOVE 0, R0 //If false
			//	JP DONE_1
			//TRUE_1 //Mind the lack of Tab! Important in FRISC! This is a tag, not a command!
			// 	MOVE 1 R0 //If true
			//DONE_1 PUSH R0 //Push the True or False we got. Again lack of tab before tag, followed by Tab and command
		}	
	}

	private static void jednakosni_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			odnosni_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			jednakosni_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}

			odnosni_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			//TODO See above, only use EQ and NEQ instead of comparing.
			//This could possibly be abstracted!
			//See angry comment in Croatian above, the same thing could be done.
		}
	}

	private static void bin_i_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			jednakosni_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			bin_i_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}

			jednakosni_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			builder.doBinaryOp("AND", null);
		}
	}

	private static void bin_xili_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			bin_i_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			bin_xili_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}

			bin_i_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			//TODO Get left and right operands, should be on stack
			//Implement using doBinaryOp with XOR operation
			//See what I did above? Just use XOR instead of AND.
		}
	}

	private static void bin_ili_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			bin_xili_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			bin_ili_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}

			bin_xili_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			//TODO Get left and right operands, should be on stack
			//Implement using doBinaryOp with OR operation
			//See above.
		}
	}

	private static void log_i_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			bin_ili_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			log_i_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}
			
			//THIS is new
			int logExprCnt = builder.getNextLogicalExpressionNumber();
			builder.freeStyle("\tPOP R0"); //We want to check the value of the first expression
			builder.freeStyle("\tCMP R0, 0"); //Is it false?
			builder.freeStyle("\tJP_NE AND_CONTINUE_" + logExprCnt); //If not carry on
			builder.freeStyle("\tPUSH R0"); //If it IS false return it on stack, we need the result
			builder.freeStyle("\tJP AND_DONE_" + logExprCnt); //But don't evaluate further, jump to end
			builder.freeStyle("AND_CONTINUE_" + logExprCnt); //Here is where we carry on
			//THIS is old
			bin_ili_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			
			//This line also new
			builder.freeStyle("AND_DONE_" + logExprCnt); //The end of the logical expression
		}
	}

	private static void log_ili_izraz(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			log_i_izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
			node.setLExpression(node.getChild(0).isLExpression());
		} else {
			log_ili_izraz(node.getChild(0));
			if (!TypeCast.canCastNodeFromTo(node.getChild(0), Type.Int, false)) {
				perror(node);
			}

			log_i_izraz(node.getChild(2));
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}

			node.setType(Type.Int);
			//TODO Get left operand. If it is 1, we know the expression true.
			//Push 1 and end. Else check the right expression and return the appropriate
			//value (0 false or 1 true)
			//See above tip
			
			//SEE ABOVE! The same goddamned thing just you don't want it to be false, but true
			//So you actually do JP_EQ instea of JP_NE.
		}
	}

	private static void slozena_naredba(SyntacticTreeNode node,
			List<Symbol> symToAdd) {
		
		//TODO Probably need to make new, empty local variables with
		//builder.enterBlock(). Not sure. If so, exit block in the end.
		table = table.makeChild();
		if (symToAdd != null) {
			for (Symbol s : symToAdd)
				table.putSymbol(s);
		}
		if (node.getChildren().size() == 3) {
			lista_naredbi(node.getChild(1));
		} else {
			lista_deklaracija(node.getChild(1));
			lista_naredbi(node.getChild(2));
		}
		table = table.getParent();
	}

	private static void lista_naredbi(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			naredba(node.getChild(0));
		} else {
			lista_naredbi(node.getChild(0));
			naredba(node.getChild(1));
		}
	}

	private static void naredba(SyntacticTreeNode node) {
		SyntaxInformationPacket info = node.getChild(0).getInfoPacket();
		if (info.type.equals("<slozena_naredba>")) {
			slozena_naredba(node.getChild(0), null);
		} else if (info.type.equals("<izraz_naredba>")) {
			izraz_naredba(node.getChild(0));
		} else if (info.type.equals("<naredba_grananja>")) {
			naredba_grananja(node.getChild(0));
		} else if (info.type.equals("<naredba_petlje>")) {
			naredba_petlje(node.getChild(0));
		} else {
			naredba_skoka(node.getChild(0));
		}
	}

	private static void izraz_naredba(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			node.setType(Type.Int);
			//TODO Produce NOP (No operation). I don't think FRISC has that, so do something silly
			//like ADD R0, 0, R0
		} else {
			izraz(node.getChild(0));
			node.inheritType(node.getChild(0));
		}
	}

	private static void naredba_grananja(SyntacticTreeNode node) {
		izraz(node.getChild(2));
		if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
			perror(node);
		}
		
		int branchNum = builder.getNextBranchNumber();
		builder.freeStyle("\tPOP R0");
		builder.freeStyle("\tCMP R0, 0"); //Compare. Is it false?! OH GOD?! IS IT FALSE?!
		builder.freeStyle("\tJP_EQ ELSE_" + branchNum); //FUCK! ABORT! ABORT! GOTO ELSE!
		
		naredba(node.getChild(4));
		builder.freeStyle("ELSE_" + branchNum);
		//If there is no else, it will just skip the if, if there IS an else, it will perform it
		if (node.getChildren().size() == 7) {
			naredba(node.getChild(6));
		}

	}

	private static void naredba_petlje(SyntacticTreeNode node) {
		if (node.getChildren().size() == 5) {
			loopCounter++;
			//TODO print label like "LOOP_COND_n" where n must be unique for loops
			izraz(node.getChild(2));
			//TODO pop value of izraz (should be boolean on stack)
			//If 0 jump to LOOP_END_n
			
			if (!TypeCast.canCastNodeFromTo(node.getChild(2), Type.Int, false)) {
				perror(node);
			}
			naredba(node.getChild(4));
			//TODO print label LOOP_BODY_END_n //Needed for continue
			//TODO JP LOOP_COND_n
			//TODO print label "LOOP_END_n"
			loopCounter--;
		} else if (node.getChildren().size() == 6) {
			loopCounter++;
			//This should be fine, done only once, no label needed
			izraz_naredba(node.getChild(2));
			//TODO Print label like "LOOP_COND_n" where n must be unique for loops
			izraz_naredba(node.getChild(3));
			//TODO pop value of izraz_naredba (should be boolean on stack)
			//If 0 jump to LOOP_END_n
			if (!TypeCast.canCastNodeFromTo(node.getChild(3), Type.Int, false)) {
				perror(node);
			}
			naredba(node.getChild(5));
			//TODO print label LOOP_BODY_END_n //Needed for continue
			//TODO JP LOOP_COND_n
			//TODO print label LOOP_END_n
			loopCounter--;
		} else if (node.getChildren().size() == 7) {
			loopCounter++;
			izraz_naredba(node.getChild(2));
			//TODO Print label like "LOOP_COND_n" where n must be unique for loops
			izraz_naredba(node.getChild(3));
			//TODO pop value of izraz_naredba (should be boolean on stack)
			//If 0 jump to LOOP_END_n
			
			//TODO JP LOOP_BODY_n, again, unique n
			if (!TypeCast.canCastNodeFromTo(node.getChild(3), Type.Int, false)) {
				perror(node);
			}
			//TODO print label LOOP_INC_n
			izraz(node.getChild(4));
			//TODO JP LOOP_COND_n
			//TODO print label LOOP_BODY_n
			naredba(node.getChild(6));
			//TODO print label LOOP_BODY_END_n //Needed for continue
			//TODO JP FOR_INC_n
			//TODO print label FOR_END_n
			loopCounter--;
		} else {
			System.err.println("Fatal error. Should never happen!!!!");
			System.exit(666);
		}
	}

	private static void naredba_skoka(SyntacticTreeNode node) {
		SyntaxInformationPacket info = node.getChild(0).getInfoPacket();
		if (node.getChildren().size() == 2) {
			if (info.type.equals("KR_RETURN")) {
				if (!functionReturnType.equals(Type.Void)) {
					perror(node);
				}
				//TODO this is returning void
				//Print RET
				//Call builder.exitFunction or something like that
			} else {
				if (loopCounter <= 0) {
					perror(node);
				}
				//TODO If it is continue, jump to LOOP_BODY_END n (getting right n could be tricky,
				//maybe another counter? Can't think of anything right now)
				// If it is break, jump to LOOP_END_n. Again, getting n is problematic
			}
		} else {
			izraz(node.getChild(1));
			if (!TypeCast.canCastNodeFromTo(node.getChild(1),
					functionReturnType, false)) {
				perror(node);
			}
			
			//TODO Return value. Pop value into R6 and then print RET
		}
	}

	private static void prijevodna_jedinica(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			vanjska_deklaracija(node.getChild(0));
		} else {
			prijevodna_jedinica(node.getChild(0));
			vanjska_deklaracija(node.getChild(1));
		}
	}

	private static void vanjska_deklaracija(SyntacticTreeNode node) {
		SyntaxInformationPacket info = node.getChild(0).getInfoPacket();
		if (info.type.equals("<definicija_funkcije>")) {
			definicija_funkcije(node.getChild(0));
		} else {
			deklaracija(node.getChild(0));
		}
	}

	private static void lista_deklaracija(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			deklaracija(node.getChild(0));
		} else {
			lista_deklaracija(node.getChild(0));
			deklaracija(node.getChild(1));
		}
	}

	private static void deklaracija(SyntacticTreeNode node) {
		ime_tipa(node.getChild(0));
		lista_init_deklaratora(node.getChild(1), node.getChild(0).getType());
	}

	private static void lista_init_deklaratora(SyntacticTreeNode node,
			Type inheritedType) {
		if (node.getChildren().size() == 1) {
			init_deklarator(node.getChild(0), inheritedType);
		} else {
			lista_init_deklaratora(node.getChild(0), inheritedType);
			init_deklarator(node.getChild(2), inheritedType);
		}
	}

	private static void init_deklarator(SyntacticTreeNode node,
			Type inheritedType) {
		if (node.getChildren().size() == 1) {
			izravni_deklarator(node.getChild(0), inheritedType);
			if (TypeCast.isConst(node.getChild(0).getType(), true)
					|| TypeCast.isConst(node.getChild(0).getType(), false)) {
				perror(node);
			}
		} else {
			izravni_deklarator(node.getChild(0), inheritedType);
			inicijalizator(node.getChild(2));

			if (TypeCast.isX(node.getChild(0).getType())) {
				if (!TypeCast.canCastNodeFromTo(node.getChild(2), node
						.getChild(0).getType(), false)) {
					perror(node);
				}

			} else if (TypeCast.isArrayX(node.getChild(0).getType())) {
				List<Type> inicijalizator = node.getChild(2).getTypes();
				List<Type> deklarator = node.getChild(0).getTypes();

				if (inicijalizator.size() > deklarator.size())
					perror(node);

				boolean isFine = true;
				for (int i = 0; i < inicijalizator.size(); i++) {
					isFine = isFine
							&& TypeCast.canCastFromTo(inicijalizator.get(i),
									deklarator.get(i), false);
				}

				if (!isFine)
					perror(node);
				
				//TODO This should be used to first declare a type in memory
				// then assign a value. Could be tricky, cannot help here without
				// doing it myself, sorry. izravni_deklarator probably does the first bit.
			} else {
				perror(node);
			}
		}
	}

	private static void izravni_deklarator(SyntacticTreeNode node,
			Type inheritedType) {
		if (node.getChildren().size() == 1) {
			if (inheritedType.equals(Type.Void)) {
				perror(node);
			}
			Symbol symbol = new Symbol(
					node.getChild(0).getInfoPacket().contents, inheritedType,
					null);
			if (!table.putSymbol(symbol)) {
				perror(node);
			}
			node.setType(inheritedType);
			//TODO Add local or global variable (builder should know which) into memory
			//Do not assign a value to it
		} else if (node.getChild(1).getInfoPacket().type
				.equals("L_UGL_ZAGRADA")) {
			if (inheritedType.equals(Type.Void)) {
				perror(node);
			}

			int number = Integer
					.valueOf(node.getChild(2).getInfoPacket().contents);
			Symbol symbol = new Symbol(
					node.getChild(0).getInfoPacket().contents,
					TypeCast.toArray(inheritedType), null);

			if (number <= 0 || number > 1024 || !table.putSymbol(symbol)) {
				perror(node);
			}

			node.setType(TypeCast.toArray(inheritedType));
			for (int i = 0; i < number; i++)
				node.addType(inheritedType);
			//TODO Add an array. This could be tricky. Probably use DS and value of child 2
			//to allocate enough space
		} else if (node.getChild(2).getInfoPacket().type.equals("KR_VOID")) {
			String name = node.getChild(0).getInfoPacket().contents;

			if (!table.declareFunction(name, inheritedType,
					new ArrayList<Type>())) {
				perror(node);
			}
			
			//TODO I think nothing but could be something. Check when you get this far
			node.setType(Type.Function);
			node.setFunctionSignature(inheritedType, new ArrayList<Type>());
		} else {
			lista_parametara(node.getChild(2));
			String name = node.getChild(0).getInfoPacket().contents;
			List<Type> types = node.getChild(2).getTypes();
			if (!table.declareFunction(name, inheritedType, types)) {
				perror(node);
			}

			//TODO Same as above
			node.setType(Type.Function);
			node.setFunctionSignature(inheritedType, types);
		}
	}

	private static void inicijalizator(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			izraz_pridruzivanja(node.getChild(0));
			int strlen = generatesString(node.getChild(0));
			if (strlen > 0) {
				for (int i = 0; i < strlen; i++) {
					node.addType(Type.Char);
				}
				
			//TODO get the string generated by child0 and then write it, character by character,
			// into the allocated memory. Maybe use shifting, but I think writing as integers should
			// work.
			} else {
				node.inheritType(node.getChild(0));
				//TODO get contents of node and do the same as above
			}
		} else {
			lista_izraza_pridruzivanja(node.getChild(1));
			node.setTypes(node.getChild(1).getTypes());
			//TODO this is a = {'a', 'b', 'c'} style of declaration
			//Get EACH value and, shifting the counter by 1 each time, write it in allocated memory
			//for variable. Not all that easy.
		}
	}

	private static void lista_izraza_pridruzivanja(SyntacticTreeNode node) {
		if (node.getChildren().size() == 1) {
			izraz_pridruzivanja(node.getChild(0));
			node.addType(node.getChild(0).getType());
		} else {
			lista_izraza_pridruzivanja(node.getChild(0));
			izraz_pridruzivanja(node.getChild(2));
			node.setTypes(node.getChild(0).getTypes());
			node.addType(node.getChild(2).getType());
		}
	}

	private static void definicija_funkcije(SyntacticTreeNode node) {
		SyntaxInformationPacket params = node.getChild(3).getInfoPacket();
		ime_tipa(node.getChild(0));
		if (params.type.equals("KR_VOID")) {
			if (TypeCast.isConst(node.getChild(0).getType(), false)
					|| TypeCast.isConst(node.getChild(0).getType(), true)
					|| !table.defineFunction(
							node.getChild(1).getInfoPacket().contents, node
									.getChild(0).getType(),
							new ArrayList<Type>())) {
				perror(node);
			}

			Type temp = functionReturnType;
			functionReturnType = node.getChild(0).getType();
			
			//TODO print label F_[function_name]
			slozena_naredba(node.getChild(5), null);
			functionReturnType = temp;

		} else {
			if (TypeCast.isConst(node.getChild(0).getType(), false)
					|| TypeCast.isConst(node.getChild(0).getType(), true)
					|| table.isDefinedFunction(node.getChild(1).getContents())) {
				perror(node);
			}

			lista_parametara(node.getChild(3));

			if (!table.defineFunction(
					node.getChild(1).getInfoPacket().contents, node.getChild(0)
							.getType(), node.getChild(3).getTypes())) {
				perror(node);
			}

			List<String> paramNames = node.getChild(3).getNames();
			List<Type> paramTypes = node.getChild(3).getTypes();

			Type temp = functionReturnType;
			functionReturnType = node.getChild(0).getType();

			List<Symbol> symToAdd = new ArrayList<Symbol>();
			// Adding function parameters as variables within scope
			for (int i = 0; i < paramNames.size(); i++) {
				symToAdd.add(new Symbol(paramNames.get(i), paramTypes.get(i),
						null));
			}

			//TODO print label F_[function_name]
			slozena_naredba(node.getChild(5), symToAdd);
			functionReturnType = temp;
		}
	}

	private static void lista_parametara(SyntacticTreeNode node) {
		//TODO I THINK nothing but time will tell
		if (node.getChildren().size() == 1) {
			deklaracija_parametra(node.getChild(0));
			node.addType(node.getChild(0).getType());
			node.addName(node.getChild(0).getName());
		} else {
			lista_parametara(node.getChild(0));
			deklaracija_parametra(node.getChild(2));
			if (node.getChild(0).getNames()
					.contains(node.getChild(2).getName())) {
				perror(node);
			}

			node.setTypes(node.getChild(0).getTypes());
			node.addType(node.getChild(2).getType());
			node.setNames(node.getChild(0).getNames());
			node.addName(node.getChild(2).getName());
		}
	}

	private static void deklaracija_parametra(SyntacticTreeNode node) {
		//TODO This could be tricky, I have no idea if anything needs to be done.
		//This is PROBABLY for adding variables (global or local).
		//Ask if help is needed.
		ime_tipa(node.getChild(0));
		if (node.getChild(0).getType().equals(Type.Void)) {
			perror(node);
		}

		node.setName(node.getChild(1).getInfoPacket().contents);
		if (node.getChildren().size() == 2) {
			node.inheritType(node.getChild(0));
		} else {
			node.setType(TypeCast.toArray(node.getChild(0).getType()));
		}
	}

	/*
	 * ################################################################# Helper
	 * functions start here! Also, some dragons are probably here. They were an
	 * hour ago, although they could have left. The helper functions make a
	 * horrible lair.
	 * #################################################################
	 */
	private static void perror(SyntacticTreeNode node) {
		StringBuilder expression = new StringBuilder();

		for (SyntacticTreeNode child : node.getChildren()) {
			expression.append(child.getInfoPacket() + " ");
		}
		System.out.println(node.getInfoPacket() + " ::= "
				+ expression.toString().trim());
		System.exit(100);
	}

	private static boolean isChar(String strRepr) {
		if (!strRepr.matches("^\'.{1,2}\'$"))
			return false;
		strRepr = strRepr.replaceAll("^\'(.{1,2})\'$", "$1");

		char min = 0;
		char max = 255;
		char val;

		if (strRepr.charAt(0) == '\\') {
			if (strRepr.length() == 2) {
				char c = strRepr.charAt(1);

				switch (c) {
				case 't':
					val = '\t';
				case 'n':
					val = '\n';
				case '0':
					val = '\0';
				case '\'':
					val = '\'';
				case '"':
					val = '"';
				case '\\':
					val = '\\';
					break;
				default:
					return false;
				}
			} else {
				return false;
			}
		} else {
			if (strRepr.equals("\"") || strRepr.equals("'"))
				return false;
			val = strRepr.charAt(0);
		}

		return (val >= min && val <= max);
	}

	private static boolean isInt(String strRepr) {
		BigInteger min = new BigInteger("-2147483648");
		BigInteger max = new BigInteger("2147483647");
		BigInteger integer = new BigInteger(strRepr);
		return (integer.compareTo(min) != -1 && integer.compareTo(max) != 1);
	}

	private static boolean isString(String strRepr) {
		if (!strRepr.matches("^\".+?\"$"))
			return false;
		strRepr = strRepr.replaceAll("^\"(.+?)\"$", "$1");
		char charRepr[] = strRepr.toCharArray();

		boolean isString = true;

		for (int i = 0; i < strRepr.length();) {
			if (charRepr[i] == '\\') {
				if (i + 1 == strRepr.length()) {
					return false;
				} else {
					isString = isString
							&& isChar("'" + charRepr[i] + charRepr[i + 1] + "'");
					i += 2;
				}
			} else {
				isString = isString && isChar("'" + charRepr[i++] + "'");
			}
		}
		return isString;
	}

	private static int generatesString(SyntacticTreeNode node) {
		SyntaxInformationPacket info = node.getInfoPacket();
		if (!info.type.matches("^<.*?>$")) {
			if (info.type.equals("NIZ_ZNAKOVA")) {
				return getStrlen(info.contents.trim());
			}

			return 0;
		}

		return generatesString(node.getChild(0));
	}

	private static int getStrlen(String s) {
		if (!isString(s))
			return 0;
		s = s.replaceAll("^\"(.+?)\"$", "$1");
		int len = 0;

		char c[] = s.toCharArray();
		for (int i = 0; i < c.length; i++) {
			if (c[i] == '\\') {
				i++;
			}
			len++;
		}

		return len;
	}
	
	private static int extractCharacterValue(String repr) {
		repr = repr.replace("'", ""); //Removing single quotes
		if(repr.length() == 2) {
			switch(repr.charAt(1)) {
			case 'n': return (int) '\n';
			case 't': return (int) '\t';
			case '0': return 0;
			case '\\': return (int) '\\';
			case '"': return (int) '"';
			case '\'': return (int) '\'';
			default: return -1;
			}
		}
		
		return (int) repr.charAt(0);
	}
	
	private static List<Integer> extractStringValue(String repr) {
		repr = repr.replaceAll("^\"(.*)\"$", "$1"); //Removing double quotes
		int length = repr.length();
		List<Integer> vals = new ArrayList<Integer>();
		
		for(int i = 0; i < length; i++) {
			if(repr.charAt(i) == '\\' && i < length - 1) {
				vals.add(extractCharacterValue("'\\" + repr.charAt(++i) + "'"));
			} else {
				vals.add((int) repr.charAt(i));
			}
		}
		
		return vals;
	}
}
